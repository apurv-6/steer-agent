---
phase: 01-gate-loop-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/mcp-server/src/index.ts
  - packages/mcp-server/src/smoke.mjs
autonomous: true
requirements:
  - MCP-03
  - MCP-04
  - REL-01

must_haves:
  truths:
    - "MCP server survives uncaught exceptions without crashing"
    - "No console.log output reaches stdout — all redirected to stderr"
    - "SIGINT and SIGTERM trigger clean exit with log message"
    - "Smoke test passes 4 cases: BLOCKED, NEEDS_INFO, READY, error handling"
    - "Server stays alive and responds after error injection"
  artifacts:
    - path: "packages/mcp-server/src/index.ts"
      provides: "Hardened MCP server"
      contains: "uncaughtException"
    - path: "packages/mcp-server/src/smoke.mjs"
      provides: "4-case smoke test"
      contains: "BLOCKED"
---

<objective>
Harden the MCP server so it doesn't crash, doesn't corrupt stdout, and handles signals cleanly. This is the highest-risk gap — a silent MCP crash means developers think "the tool is broken."

Day 1 work. ~2 hours of actual code changes.
</objective>

<context>
@packages/mcp-server/src/index.ts
@packages/mcp-server/src/gate.ts
@packages/mcp-server/src/smoke.mjs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add stdout guard, error handlers, signal handling to MCP server</name>
  <files>
    packages/mcp-server/src/index.ts
  </files>
  <action>
Add these at the VERY TOP of packages/mcp-server/src/index.ts, before any other imports:

1. **Stdout guard** — redirect console.log to stderr:
   ```typescript
   const _origLog = console.log;
   console.log = (...args: unknown[]) => console.error("[mcp-log]", ...args);
   ```

2. **Global error handlers** — keep server alive:
   ```typescript
   process.on("uncaughtException", (err) => {
     console.error("[mcp-fatal] uncaughtException:", err);
   });
   process.on("unhandledRejection", (reason) => {
     console.error("[mcp-fatal] unhandledRejection:", reason);
   });
   ```

3. **Signal handling** — clean shutdown:
   ```typescript
   for (const sig of ["SIGINT", "SIGTERM"] as const) {
     process.on(sig, () => {
       console.error(`[mcp] ${sig} received, shutting down`);
       process.exit(0);
     });
   }
   ```

4. **Wrap handleGate in try/catch** — return MCP error format on failure:
   ```typescript
   try {
     const result = gate({ ... });
     return { content: [{ type: "text" as const, text: JSON.stringify(result, null, 2) }] };
   } catch (err) {
     const msg = err instanceof Error ? err.message : String(err);
     console.error("[mcp] gate error:", msg);
     return { content: [{ type: "text" as const, text: JSON.stringify({ error: msg }) }], isError: true };
   }
   ```

5. **Add stdin keepalive** at end of startServer:
   ```typescript
   process.stdin.resume();
   ```

Do NOT restructure the file. Only add hardening. Keep existing server creation, tool registration, and transport setup intact.
  </action>
  <verify>
    `npm run build` for mcp-server succeeds. Start server: `node packages/mcp-server/dist/index.cjs` — verify it waits for stdin without stdout output.
  </verify>
  <done>
    MCP server has stdout guard, error handlers, signal handlers, gate error protection, and stdin keepalive. No structural changes to existing code.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update smoke test for 4 cases including error survival</name>
  <files>
    packages/mcp-server/src/smoke.mjs
  </files>
  <action>
Read existing smoke.mjs to understand structure. Ensure it covers these 4 cases:

1. **BLOCKED**: Send "fix it" → verify status === "BLOCKED", score <= 3
2. **NEEDS_INFO**: Send prompt with GOAL but missing LIMITS/REVIEW → verify status === "NEEDS_INFO", followupQuestions.length > 0
3. **READY**: Send well-structured prompt with GOAL + LIMITS + REVIEW → verify status === "READY", score >= 7
4. **Server survival**: After all cases, send one more valid request to verify server is still responsive

Add an assertion that stdout contains only valid JSON-RPC messages (no stray text from console.log).

Keep it as a standalone .mjs file runnable with `node packages/mcp-server/src/smoke.mjs`.
  </action>
  <verify>
    `npm run build` for core + mcp-server. Run `node packages/mcp-server/src/smoke.mjs` — all cases pass, exit code 0.
  </verify>
  <done>
    Smoke test validates all 3 gate statuses + server survival + stdout purity. Exit 0 on pass, exit 1 on fail.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds for mcp-server
2. `node packages/mcp-server/src/smoke.mjs` exits 0
3. Server process stays alive after error case
4. No stdout corruption (console.log redirected)
</verification>

<output>
After completion, create `.planning/phases/01-gate-loop-hardening/01-01-SUMMARY.md`
</output>
