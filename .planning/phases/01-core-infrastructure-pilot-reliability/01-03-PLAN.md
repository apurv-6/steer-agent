---
phase: 01-core-infrastructure-pilot-reliability
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - hooks/steer-gate-hook.js
  - packages/cursor-extension/src/hookBridge.ts
  - packages/cursor-extension/src/SessionState.ts
  - packages/cursor-extension/src/extension.ts
  - hooks/cursor-hooks.example.json
autonomous: true
requirements:
  - ARCH-03
  - ARCH-07
  - HOOK-01
  - HOOK-02
  - HOOK-03
  - HOOK-04
  - HOOK-05
  - EXT-05
  - REL-02
  - REL-03
  - SESS-02

must_haves:
  truths:
    - "Hook writes GateResult to .steer-agent/last-gate.json signal file after every gate() call"
    - "Signal file write uses atomic tmp+rename pattern to prevent half-reads"
    - "HookBridge FileSystemWatcher detects signal file changes and emits hook:signal on EventBus"
    - "HookBridge debounces watcher events (150ms) and deduplicates by timestamp"
    - "Extension SessionState imports SessionStateData from core (no duplicate type)"
    - "Extension activates gracefully even if chat participant API fails (try/catch with fallback)"
    - "Hook completes well under 5-second Cursor timeout"
  artifacts:
    - path: "hooks/steer-gate-hook.js"
      provides: "CJS hook with signal file write"
      contains: "renameSync"
    - path: "packages/cursor-extension/src/hookBridge.ts"
      provides: "FileSystemWatcher bridge from hook signal file to EventBus"
      exports: ["HookBridge"]
    - path: "packages/cursor-extension/src/SessionState.ts"
      provides: "MementoPersistence adapter implementing PersistenceAdapter from core"
      exports: ["MementoPersistence"]
  key_links:
    - from: "hooks/steer-gate-hook.js"
      to: ".steer-agent/last-gate.json"
      via: "fs.writeFileSync + renameSync (atomic write)"
      pattern: "renameSync"
    - from: "packages/cursor-extension/src/hookBridge.ts"
      to: "packages/core/src/eventBus.ts"
      via: "bus.emit('hook:signal', { source, result })"
      pattern: "bus\\.emit.*hook:signal"
    - from: "packages/cursor-extension/src/extension.ts"
      to: "packages/cursor-extension/src/hookBridge.ts"
      via: "new HookBridge(eventBus) in activate(), push to subscriptions"
      pattern: "new HookBridge"
---

<objective>
Wire the hook-to-extension bridge: update the hook to write a signal file after gating, build the HookBridge FileSystemWatcher in the extension, refactor SessionState to use core types and implement PersistenceAdapter, and add graceful error handling throughout the extension.

Purpose: This creates the real-time feedback loop: user submits prompt -> hook fires -> gate() scores -> signal file written -> extension picks it up -> panels update. Without this bridge, the extension is blind to hook activity.

Output: Updated hook with signal file write, new HookBridge class, refactored SessionState as MementoPersistence adapter, hardened extension activation.
</objective>

<execution_context>
@/Users/devapu/.claude/get-shit-done/workflows/execute-plan.md
@/Users/devapu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-infrastructure-pilot-reliability/01-RESEARCH.md
@.planning/phases/01-core-infrastructure-pilot-reliability/01-01-SUMMARY.md

@hooks/steer-gate-hook.js
@packages/cursor-extension/src/extension.ts
@packages/cursor-extension/src/SessionState.ts
@packages/cursor-extension/src/gateClient.ts
@packages/core/src/constants.ts
@packages/core/src/eventBus.ts
@packages/core/src/sessionStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add signal file write to hook and create HookBridge</name>
  <files>
    hooks/steer-gate-hook.js
    packages/cursor-extension/src/hookBridge.ts
    hooks/cursor-hooks.example.json
  </files>
  <action>
1. **Update `hooks/steer-gate-hook.js`** (HOOK-03 -- signal file write):
   - After the `const gateResult = gate({...})` call (line ~102) and BEFORE building hookOutput, add signal file write:
     ```javascript
     // Write signal file for extension bridge (best-effort)
     const SIGNAL_DIR_NAME = ".steer-agent";
     const SIGNAL_FILE_NAME = "last-gate.json";
     try {
       const signalDir = path.join(process.cwd(), SIGNAL_DIR_NAME);
       if (!fs.existsSync(signalDir)) {
         fs.mkdirSync(signalDir, { recursive: true });
       }
       const signalData = {
         ...gateResult,
         _timestamp: new Date().toISOString(),
         _source: "beforeSubmitPrompt",
       };
       const tmpPath = path.join(signalDir, ".last-gate.tmp");
       const finalPath = path.join(signalDir, SIGNAL_FILE_NAME);
       fs.writeFileSync(tmpPath, JSON.stringify(signalData, null, 2));
       fs.renameSync(tmpPath, finalPath);
     } catch {
       // Signal file is best-effort; do not fail the hook
     }
     ```
   - Ensure this is BEFORE `process.stdout.write(JSON.stringify(hookOutput))` so extension gets the result even if Cursor kills the process
   - Confirm the hook still works end-to-end: stdin -> gate -> signal file -> stdout
   - Verify HOOK-01 (CJS format), HOOK-02 (blocking policy), HOOK-04 (under 5s), HOOK-05 (example config) are all preserved

2. **Update `hooks/cursor-hooks.example.json`** (HOOK-05):
   - Ensure the example config references the correct hook path and event
   - Add a comment field explaining signal file location:
     ```json
     {
       "hooks": {
         "beforeSubmitPrompt": {
           "command": "node",
           "args": ["./hooks/steer-gate-hook.js"],
           "timeout": 5000
         }
       },
       "_notes": {
         "signal_file": "Hook writes gate results to .steer-agent/last-gate.json for extension pickup"
       }
     }
     ```

3. **Create `packages/cursor-extension/src/hookBridge.ts`** (ARCH-03):
   - Import `vscode`, `fs/promises`, `path` from Node.js
   - Import `SIGNAL_DIR`, `SIGNAL_FILE` from `@steer-agent-tool/core`
   - Import type `SteerEventBus` and `GateResult` from `@steer-agent-tool/core`
   - Implement `HookBridge` class implementing `vscode.Disposable`:
     - Constructor: takes `SteerEventBus`, creates `vscode.FileSystemWatcher` for `**/${SIGNAL_DIR}/${SIGNAL_FILE}` using RelativePattern from first workspace folder
     - Subscribe to `onDidChange` and `onDidCreate` events
     - `handleChange()`: debounce with 150ms timeout (clear existing timer, set new one)
     - `processSignalFile()`: async method that reads the signal file, parses JSON, checks `_timestamp` against `lastProcessedTimestamp` to deduplicate, emits `hook:signal` event on bus
     - On startup: if signal file exists and timestamp is within last 30 seconds, process it (handles extension restart case). Otherwise ignore stale data.
     - `dispose()`: dispose watcher, clear debounce timer
   - All file reads use `fs.promises.readFile` (async, never blocking)
   - Entire processSignalFile wrapped in try/catch (ARCH-03 reliability)
  </action>
  <verify>
    Run the hook manually: `echo '{"prompt":"Fix the bug"}' | node hooks/steer-gate-hook.js` and verify `.steer-agent/last-gate.json` is created with valid JSON containing `_timestamp` field. Verify the hook completes in under 2 seconds: `time echo '{"prompt":"test"}' | node hooks/steer-gate-hook.js`. Verify `npm run build` succeeds for cursor-extension package.
  </verify>
  <done>
    Hook writes atomic signal file on every gate call. HookBridge watches for changes with 150ms debounce and timestamp dedup. Signal file contains full GateResult plus _timestamp and _source metadata.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor SessionState to MementoPersistence and harden extension activation</name>
  <files>
    packages/cursor-extension/src/SessionState.ts
    packages/cursor-extension/src/extension.ts
  </files>
  <action>
1. **Refactor `packages/cursor-extension/src/SessionState.ts`** (ARCH-07, SESS-02):
   - Remove the duplicate `GateMode` and `SessionStateData` type definitions (import from core instead)
   - Remove the `SessionState` class (replaced by `SessionStore` from core)
   - Create and export `MementoPersistence` class implementing `PersistenceAdapter` from core:
     ```typescript
     import type { PersistenceAdapter, SessionStateData } from "@steer-agent-tool/core";
     import { STORAGE_KEY } from "@steer-agent-tool/core";
     import * as vscode from "vscode";

     export class MementoPersistence implements PersistenceAdapter {
       constructor(private memento: vscode.Memento) {}

       load(): SessionStateData | undefined {
         return this.memento.get<SessionStateData>(STORAGE_KEY);
       }

       save(data: SessionStateData): void {
         this.memento.update(STORAGE_KEY, data);
       }
     }
     ```
   - This is a thin adapter â€” all logic lives in core's SessionStore

2. **Update `packages/cursor-extension/src/extension.ts`** (EXT-05, REL-02, REL-03):
   - Import `eventBus`, `SessionStore`, `telemetry` from `@steer-agent-tool/core`
   - Import `MementoPersistence` from `./SessionState.js`
   - Import `HookBridge` from `./hookBridge.js`
   - In `activate()`:
     a. Create `MementoPersistence` from `context.workspaceState`
     b. Create `SessionStore` with persistence + eventBus
     c. Set up telemetry: `const telemetryPath = path.join(context.globalStorageUri.fsPath, "telemetry.jsonl"); telemetry.subscribeToEventBus(eventBus, telemetryPath);` (TELE-02)
     d. Create and register `HookBridge`: `const bridge = new HookBridge(eventBus); context.subscriptions.push(bridge);`
     e. Subscribe to `gate:result` on eventBus to update SessionStore:
        ```typescript
        eventBus.on("gate:result", (result) => {
          store.update({
            lastScore: result.score,
            lastStatus: result.status,
            turnId: result.turnId,
            taskId: result.taskId,
            gateCallCount: store.data.gateCallCount + 1,
            lastModelTier: result.modelSuggestion.tier,
            blockedCount: store.data.blockedCount + (result.status === "BLOCKED" ? 1 : 0),
          });
        });
        ```
     f. Wrap chat participant registration in try/catch (REL-03):
        ```typescript
        try {
          // existing chat participant code
        } catch (err) {
          console.warn("[steer] Chat participant unavailable in this editor:", err);
          // Extension continues to work via MCP + hook bridge
        }
        ```
     g. Wrap panel registrations in try/catch (EXT-05, REL-02)
     h. Add eventBus.dispose() to deactivate function
   - Replace any direct `SessionState` usage with the new `SessionStore` instance
   - Ensure `context.globalStorageUri` directory is created if needed (VS Code may not create it automatically): `await vscode.workspace.fs.createDirectory(context.globalStorageUri);`
  </action>
  <verify>
    Run `npm run build` for cursor-extension package -- compiles without errors. Verify no `import * as vscode` in any core package file. Verify SessionState.ts no longer defines GateMode or SessionStateData types (imports from core). Verify extension.ts has try/catch around chat participant and panel registrations.
  </verify>
  <done>
    SessionState refactored to thin MementoPersistence adapter (no duplicate types). Extension activation creates SessionStore + HookBridge + telemetry subscription. Chat participant and panels wrapped in try/catch for graceful degradation. eventBus cleaned up on deactivate.
  </done>
</task>

</tasks>

<verification>
1. Hook writes `.steer-agent/last-gate.json` with valid JSON on every invocation
2. Signal file uses atomic write pattern (tmp + rename)
3. `npm run build` succeeds for both core and cursor-extension packages
4. No duplicate type definitions between core and extension
5. Extension compiles with HookBridge, MementoPersistence, and EventBus wiring
6. Chat participant registration wrapped in try/catch
7. Hook completes in under 2 seconds for typical prompts
</verification>

<success_criteria>
- Hook-to-extension bridge operational: hook writes signal file, extension watches and processes it
- SessionState reduced to a thin persistence adapter (all logic in core SessionStore)
- Extension activates cleanly even when chat participant API is unavailable
- All error paths handled gracefully (no unhandled exceptions crash extension)
- Signal file deduplication prevents processing same event twice
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-infrastructure-pilot-reliability/01-03-SUMMARY.md`
</output>
