---
phase: 01-core-infrastructure-pilot-reliability
plan: 04
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - packages/mcp-server/src/index.ts
  - packages/mcp-server/src/smoke.mjs
  - packages/mcp-server/tsup.config.ts
autonomous: true
requirements:
  - MCP-01
  - MCP-02
  - MCP-03
  - MCP-04
  - REL-01

must_haves:
  truths:
    - "MCP server survives uncaught exceptions without crashing (process stays alive)"
    - "No console.log output reaches stdout (all redirected to stderr)"
    - "SIGINT and SIGTERM are handled gracefully with clean exit"
    - "Smoke test passes all 4 gate status cases (BLOCKED, NEEDS_INFO, READY, error handling)"
    - "MCP server starts, accepts steer.gate tool calls, and returns valid GateResult JSON"
  artifacts:
    - path: "packages/mcp-server/src/index.ts"
      provides: "Hardened MCP server with error handlers, signal handling, stdout audit"
      contains: "uncaughtException"
    - path: "packages/mcp-server/src/smoke.mjs"
      provides: "Smoke test validating all gate statuses via MCP protocol"
      contains: "BLOCKED"
  key_links:
    - from: "packages/mcp-server/src/index.ts"
      to: "packages/core/src/gate.ts"
      via: "gate() relay through handleGate()"
      pattern: "gate\\("
    - from: "packages/mcp-server/src/smoke.mjs"
      to: "packages/mcp-server/src/index.ts"
      via: "child_process spawn of MCP server, JSON-RPC calls"
      pattern: "spawn.*mcp"
---

<objective>
Harden the MCP server to survive errors, handle signals cleanly, prevent stdout corruption, and verify with a comprehensive smoke test. This ensures the MCP integration path is reliable for the CoinSwitch pilot.

Purpose: MCP is the primary integration path (per key decisions). If the MCP server crashes or corrupts its stdout stream, Cursor silently disconnects and developers lose the steer.gate tool. This plan makes the server production-ready.

Output: Hardened MCP server index.ts with error/signal handlers and stdout audit. Updated smoke test validating all cases.
</objective>

<execution_context>
@/Users/devapu/.claude/get-shit-done/workflows/execute-plan.md
@/Users/devapu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-infrastructure-pilot-reliability/01-RESEARCH.md
@.planning/phases/01-core-infrastructure-pilot-reliability/01-01-SUMMARY.md

@packages/mcp-server/src/index.ts
@packages/mcp-server/src/gate.ts
@packages/mcp-server/src/smoke.mjs
@packages/mcp-server/tsup.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add stdout audit, error handlers, and signal handling to MCP server</name>
  <files>
    packages/mcp-server/src/index.ts
  </files>
  <action>
1. **Add hardening at the VERY TOP of `packages/mcp-server/src/index.ts`** (before any other imports):
   ```typescript
   // ── MCP Server Hardening (MUST be first) ──────────────────────────
   // Stdout audit: redirect console.log to stderr to prevent JSON-RPC corruption
   // MCP uses stdout exclusively for JSON-RPC framing. Any stray console.log
   // corrupts the stream and causes silent disconnection.
   const _origLog = console.log;
   console.log = (...args: unknown[]) => console.error("[mcp-log]", ...args);

   // Global error handlers: keep server alive on unhandled errors
   process.on("uncaughtException", (err) => {
     console.error("[mcp-fatal] uncaughtException:", err);
     // Do NOT exit -- MCP server must stay alive (REL-01)
   });
   process.on("unhandledRejection", (reason) => {
     console.error("[mcp-fatal] unhandledRejection:", reason);
     // Do NOT exit
   });

   // Signal handling: clean shutdown
   for (const sig of ["SIGINT", "SIGTERM"] as const) {
     process.on(sig, () => {
       console.error(`[mcp] ${sig} received, shutting down gracefully`);
       process.exit(0);
     });
   }
   ```

2. **Ensure stdin stays open** -- add at the end of `startServer()`:
   ```typescript
   // Prevent premature exit if stdin closes unexpectedly
   process.stdin.resume();
   ```

3. **Audit all imports and the gate relay** for any console.log calls:
   - Check `packages/mcp-server/src/gate.ts` -- should be clean (it's a thin relay)
   - The core gate() function should not have console.log (verify)
   - If any console.log exists in reachable code paths, either remove them or they'll be caught by the redirect above

4. **Wrap handleGate in error protection**:
   ```typescript
   async function handleGate(args: { ... }) {
     try {
       const result = gate({ ... });
       return {
         content: [{ type: "text" as const, text: JSON.stringify(result, null, 2) }],
       };
     } catch (err) {
       const message = err instanceof Error ? err.message : String(err);
       console.error("[mcp] gate error:", message);
       return {
         content: [{ type: "text" as const, text: JSON.stringify({ error: message }, null, 2) }],
         isError: true,
       };
     }
   }
   ```

5. **Keep existing MCP server structure intact**: McpServer creation, GateParamsSchema, server.tool registration, StdioServerTransport. Only add hardening, do not restructure.
  </action>
  <verify>
    Run `npm run build` for mcp-server package. Start the server: `node packages/mcp-server/dist/index.cjs` -- verify it starts without errors and waits for stdin. Send a SIGINT -- verify it exits cleanly with the log message. Verify no output appears on stdout at startup (only stderr).
  </verify>
  <done>
    MCP server has stdout audit (console.log -> stderr), uncaughtException and unhandledRejection handlers that keep server alive, SIGINT/SIGTERM clean exit, handleGate error protection, and stdin keepalive. Server stays alive on errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update smoke test to validate all gate statuses and error handling</name>
  <files>
    packages/mcp-server/src/smoke.mjs
  </files>
  <action>
1. **Read existing `packages/mcp-server/src/smoke.mjs`** to understand current test structure.

2. **Ensure the smoke test covers all 4 required cases** (MCP-04):
   - Case 1: BLOCKED status -- send a vague prompt with no sections (e.g., "fix it"), verify `status === "BLOCKED"` and `score <= 3`
   - Case 2: NEEDS_INFO status -- send a prompt with some structure but missing sections (score 4-6), verify `status === "NEEDS_INFO"` and `followupQuestions.length > 0`
   - Case 3: READY status -- send a well-structured prompt with GOAL, LIMITS, REVIEW sections, verify `status === "READY"` and `score >= 7`
   - Case 4: Error handling -- send invalid input (e.g., missing required `draftPrompt` field), verify the server returns an error response without crashing

3. **Update assertions for new fields** added in Plan 01-02:
   - Verify `criterionScores` exists in the response and has keys (goal, limits, review, clarity, scope)
   - Verify `modelSuggestion.modelName` and `modelSuggestion.provider` are strings

4. **Add stdout purity check** (MCP-03):
   - Capture stdout and stderr separately from the child process
   - After all test cases, verify that stdout contains ONLY valid JSON-RPC messages (no stray text)
   - Stderr may contain log messages -- that's expected

5. **Add server survival check** (REL-01):
   - After all test cases complete, verify the server process is still alive (not crashed)
   - Send one final valid request to confirm the server is responsive

6. **Keep the smoke test as a standalone .mjs file** that can be run with `node packages/mcp-server/src/smoke.mjs`. Use child_process to spawn the MCP server, write JSON-RPC requests to its stdin, and read responses from stdout. Exit 0 on all pass, exit 1 on any failure.
  </action>
  <verify>
    Run `npm run build` for core and mcp-server packages. Run `node packages/mcp-server/src/smoke.mjs` -- all 4+ test cases pass with assertions. Verify exit code is 0.
  </verify>
  <done>
    Smoke test validates BLOCKED, NEEDS_INFO, READY statuses, error handling, stdout purity, new response fields (criterionScores, modelName, provider), and server survival. All assertions pass. Test exits cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds for mcp-server package
2. MCP server starts and stays alive (no premature exit)
3. No stdout corruption -- console.log redirected to stderr
4. SIGINT/SIGTERM handled gracefully
5. Smoke test passes all 4+ cases
6. Server survives after error case (still responsive)
7. handleGate returns MCP-compliant error format on gate() failure
</verification>

<success_criteria>
- MCP server is production-ready: survives errors, handles signals, no stdout corruption
- Smoke test validates all gate statuses and new response fields
- Server stays alive after uncaught exceptions
- All 5 requirement IDs verified (MCP-01 through MCP-04, REL-01)
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-infrastructure-pilot-reliability/01-04-SUMMARY.md`
</output>
